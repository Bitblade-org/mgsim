#include "sim/modelregistry.h"
#include <algorithm>
#include <cctype>
#include <iostream>

using namespace std;
using namespace Simulator;

bool
ComponentModelRegistry::Entity::operator<(const ComponentModelRegistry::Entity& right) const
{
    return (type < right.type ||
            (type == right.type && type != VOID &&
             (
                 (type == UINT && value < right.value) ||
                 (type == SYMBOL && symbol < right.symbol) ||
                 (type == OBJECT && object < right.object))));
};

ComponentModelRegistry::ComponentModelRegistry()
    : m_symbols(),
      m_objects(),
      m_entities(),
      m_objprops(),
      m_linkprops(),
      m_names()
{}


ComponentModelRegistry::Symbol
ComponentModelRegistry::makeSymbol(const string& sym)
{
    string str(sym);
    transform(str.begin(), str.end(), str.begin(), ::tolower);
    auto i = m_symbols.insert(str);
    return &(*i.first);
}

ComponentModelRegistry::ObjectRef
ComponentModelRegistry::refObject(const Simulator::Object& obj)
{
    auto obj_declaration = m_objects.find(&obj);
    assert(obj_declaration != m_objects.end());

    return obj_declaration->first;
}

ComponentModelRegistry::EntityRef
ComponentModelRegistry::refEntity(const ObjectRef& obj)
{
    assert(m_objects.find(obj) != m_objects.end());
    Entity e;
    e.type = Entity::OBJECT;
    e.object = obj;
    auto i = m_entities.insert(e);
    return &(*i.first);
}

ComponentModelRegistry::EntityRef
ComponentModelRegistry::refEntity(const char *str)
{
    return refEntity(makeSymbol(str));
}

ComponentModelRegistry::EntityRef
ComponentModelRegistry::refEntity(const string& str)
{
    return refEntity(makeSymbol(str));
}


ComponentModelRegistry::EntityRef
ComponentModelRegistry::refEntity(const Symbol& sym)
{
    assert(m_symbols.find(*sym) != m_symbols.end());
    Entity e;
    e.type = Entity::SYMBOL;
    e.symbol = sym;
    auto i = m_entities.insert(e);
    return &(*i.first);
}

ComponentModelRegistry::EntityRef
ComponentModelRegistry::refEntity(const uint32_t& val)
{
    Entity e;
    e.type = Entity::UINT;
    e.value = val;
    auto i = m_entities.insert(e);
    return &(*i.first);
}

ComponentModelRegistry::EntityRef
ComponentModelRegistry::refEntity(void)
{
    Entity e;
    e.type = Entity::VOID;
    auto i = m_entities.insert(e);
    return &(*i.first);
}

void
ComponentModelRegistry::registerObject(const Object& obj,
                                       const string& type)
{
    assert(m_objects.find(&obj) == m_objects.end()
           || m_objects.find(&obj)->second == makeSymbol(type));
    m_objects[&obj] = makeSymbol(type);
}

void ComponentModelRegistry::renameObjects()
{
    map<Symbol, int> typecounters;
    m_names.clear();
    for (auto& i : m_objects)
    {
        m_names[i.first] = makeSymbol(*i.second + to_string(typecounters[i.second]++));
    }
}

void
ComponentModelRegistry::printEntity(ostream& os,
                                    const ComponentModelRegistry::Entity& e) const
{
    switch(e.type)
    {
    case Entity::VOID: os << "(void)"; break;
    case Entity::SYMBOL: os << *e.symbol; break;
    case Entity::OBJECT:
        assert(m_names.find(e.object) != m_names.end());
        os << *m_names.find(e.object)->second;
        break;
    case Entity::UINT: os << dec << e.value; break;
    }
}

void
ComponentModelRegistry::dumpComponentGraph(ostream& os,
                                           bool display_nodeprops,
                                           bool display_linkprops)
{
    renameObjects();

    os << "# Microgrid system topology, generated by " << PACKAGE_NAME << " " << PACKAGE_VERSION << endl
       << "digraph Microgrid {" << endl
       << "overlap=\"false\"; labeljust=\"l\"; concentrate=\"true\"; splines=\"true\"; node [shape=box]; edge [len=2,constraint=\"false\"];" << endl;
    for (auto& i : m_objects)
    {
        ObjectRef objref = i.first;
        os << *m_names[objref] << " [label=\"" << *m_names[objref];

        string name = objref->GetName();
        if (name != *m_names[objref])
            os << "\\nconfig:" << name;

        if (display_nodeprops && !m_objprops[objref].empty())
        {
            for (auto& p : m_objprops[objref])
            {
                os << "\\n" << *p.first;
                if (p.second->type != Entity::VOID)
                {
                    os << ':';
                    printEntity(os, *p.second);
                }
            }
        }
        os << "\"];" << endl;
    }

    for (auto& i : m_linkprops)
    {
        auto& endpoints = i.first;
        auto& props = i.second;

        os << *m_names[endpoints.first] << " -> " << *m_names[endpoints.second.first]
           << " [constraint=\"" << (endpoints.second.second.first ? "false" : "true") << "\"";

        if (endpoints.second.second.second)
            os << ",dir=both";

        if (display_linkprops)
        {
            os << ",label=\"";
            for (auto& p : props)
            {
                os << *p.first;
                if (p.second->type != Entity::VOID)
                {
                    os << ':';
                    printEntity(os, *p.second);
                }
                os << ' ';
            }
            os << "\"";
        }
        os << "];"  << endl;
    }
    os << "}" << endl;
}
